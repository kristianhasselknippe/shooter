use camera::OrthoCamera;
use drawing::*;
use gl;
use gl::types::*;
use imgui::*;
use input::Input;
use na::Point3;
use shader::ShaderProgram;
use std::os::raw::c_char;
use std::ptr::{null, null_mut};
use utils::gl::{*, texture::*};

macro_rules! cstr {
    ($s:expr) => {
        concat!($s, "\0") as *const str as *const [c_char] as *const c_char
    };
}

pub struct Gui {
    context: *mut ImGuiContext,
    io: *mut ImGuiIO,

    shader: ShaderProgram,
}

impl Gui {
    pub fn init_gui(w: f32, h: f32) -> Gui {
        let shader = ShaderProgram::create_program("gui");

        println!("InitGUI: {},{}", w, h);
        unsafe {
            // Application init
            let ctx = igCreateContext(None, None);
            let io = igGetIO();
            (*io).display_size.x = w;
            (*io).display_size.y = h;

            println!("PWN: {:#?}", ::std::env::current_dir());
            ImFontAtlas_AddFontFromFileTTF(
                (*io).fonts,
                cstr!("./assets/fonts/Lato-Regular.ttf"),
                15.0,
                null_mut(),
                null_mut(),
            );

            let mut pixels: *mut u8 = null_mut();
            let mut width: i32 = 0;
            let mut height: i32 = 0;
            let mut bytes_per_pixel: i32 = 0;

            ImFontAtlas_GetTexDataAsRGBA32(
                (*io).fonts,
                &mut pixels as *mut *mut u8,
                &mut width as *mut i32,
                &mut height as *mut i32,
                &mut bytes_per_pixel as *mut i32,
            );
            println!(
                "Pixels adr: {}, width: {}, height: {}, bbp: {}",
                pixels as i32, width, height, bytes_per_pixel
            );

            /*let mut cdir = ::std::env::current_dir().unwrap();
            cdir.push("font_tex.png");
            let pixel_slice: &[u8] =
                ::std::slice::from_raw_parts(pixels, (width * height * bytes_per_pixel) as usize);
            ::utils::img::save_as_image(
                &cdir,
                pixel_slice,
                width as _,
                height as _,
                bytes_per_pixel as _,
            );*/

            let mut font_texture = Texture::new();
            font_texture.bind_to_texture_unit(0);
            font_texture.upload(pixels, width as u32, height as u32, bytes_per_pixel);
            //upload

            // TODO: Store your texture pointer/identifier (whatever your engine uses) in 'io.Fonts->TexID'.
            //This will be passed back to your via the renderer.
            println!("Setting fontatlas texture id to: {}", font_texture.handle);
            ImFontAtlas_SetTexID((*io).fonts, font_texture.handle as _);

            Gui {
                context: ctx,
                io: io,
                shader: shader,
            }
        }
    }

    pub fn new_frame(&mut self) {
        unsafe {
            igNewFrame();
        }
    }

    pub fn render(&mut self, w: f32, h: f32) {
        unsafe {
            // Render & swap video buffers
            igRender();
            /*MyImGuiRenderFunction(ImGui::GetDrawData());
            SwapBuffers();*/
            self.my_render_function(igGetDrawData(), w, h);
        }
    }

    pub fn update_input(&mut self, input: &Input, dt: f32) {
        unsafe {
            (*self.io).delta_time = dt;
            (*self.io).mouse_pos = ImVec2::new(input.mouse_pos.x, input.mouse_pos.y);
            (*self.io).mouse_down[0] = input.mouse_left;
            (*self.io).mouse_down[1] = input.mouse_right;
        }
    }

    pub fn draw_test(&mut self) {
        unsafe {
            igText(cstr!("Hello, world"));
            igText(cstr!("Hello, world 2"));
            igText(cstr!("Hello, world 3"));
            if igButton(cstr!("Save"), ImVec2::new(150.0, 80.0)) {}
            //igInputText(cstr("string"), buf, IM_ARRAYSIZE(buf));
            //igSliderFloat("float", &f, 0.0f, 1.0f);
        }
    }

    fn my_render_function(&mut self, draw_data: *mut ImDrawData, w: f32, h: f32) {
        unsafe {
            let cmd_lists_count = (*draw_data).cmd_lists_count;
            for &cmd_list in (*draw_data).cmd_lists() {
                let vtx_buffer = (*cmd_list).vtx_buffer.data; // vertex buffer generated by ImGui
                let mut idx_buffer = (*cmd_list).idx_buffer.data; // index buffer generated by ImGui
                for cmd_i in 0..(*cmd_list).cmd_buffer.size {
                    let pcmd = &(*cmd_list).cmd_buffer.as_slice()[cmd_i as usize];
                    if let Some(user_callback) = (*pcmd).user_callback {
                        user_callback(cmd_list, pcmd);
                    } else {
                        let tid = pcmd.texture_id;

                        //TODO: MyEngineScissor((int)pcmd->ClipRect.x, (int)pcmd->ClipRect.y, (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));
                        self.draw_indexed_triangles(
                            if ::std::mem::size_of::<ImDrawIdx>() == 2 {
                                gl::UNSIGNED_SHORT
                            } else {
                                gl::UNSIGNED_INT
                            },
                            &(*cmd_list).idx_buffer,
                            &(*cmd_list).vtx_buffer,
                            tid as _,
                            w,
                            h,
                        );
                    }
                    idx_buffer.add((*pcmd).elem_count as usize);
                }
            }
        }
    }

    fn draw_indexed_triangles(
        &mut self,
        element_type: GLenum,
        elements: &ImVector<ImDrawIdx>,
        vertices: &ImVector<ImDrawVert>,
        texture_handle: u32,
        w: f32,
        h: f32,
    ) {
        let mut vao = gen_vertex_array();
        vao.bind();

        let mut vbo = Buffer::gen_vbo();
        vbo.bind();
        let mut ebo = Buffer::gen_ebo();
        ebo.bind();

        let camera = OrthoCamera::new(w, h);

        disable(Capability::CullFace);
        disable(Capability::DepthTest);
        enable(Capability::Blend);
        enable(Capability::ScissorTest);

        enable_vertex_attribs(&[
            VertexAttribute::new(0, gl::FLOAT, 2, false),
            VertexAttribute::new(1, gl::FLOAT, 2, false),
            VertexAttribute::new(2, gl::UNSIGNED_BYTE, 4, true),
        ]);

        let verts_size = vertices.size * ::std::mem::size_of::<ImDrawVert>() as i32;
        let elems_size = elements.size * ::std::mem::size_of::<ImDrawIdx>() as i32;
        vbo.upload_data(vertices.data as _, verts_size as isize);
        ebo.upload_data(elements.data as _, elems_size as isize);

        self.shader.use_program();
        self.shader.set_mat4("proj", &camera.projection);
        self.shader.set_int("tex", 0);

        draw_triangles(elems_size, element_type);

        vbo.delete();
        ebo.delete();
        vao.delete();
    }
}

impl Drop for Gui {
    fn drop(&mut self) {
        unsafe {
            igDestroyContext(self.context);
        }
    }
}
